#pragma once

#include <defines.h>
#include <platform/string.h>
#include <math/math_types.h>

/*
    @brief Получает количество символов предоставленной строки.
    @param str Указатель на строку.
    @return Количество символов строки.
*/
#define string_length(str) platform_string_length(str)

/*
    @brief Посимвольно сравнивает две строки с учетом регистра символов.
    @param lstr Указатель на первую cтроку.
    @param rstr Указатель на вторую cтрока.
    @return True если строки одинаковые, false разные.
*/
#define string_equal(lstr, rstr) platform_string_equal(lstr, rstr)

/*
    @brief Посимвольно сравнивает две строки без учетом регистра символов.
    @param lstr Указатель на первую cтроку.
    @param rstr Указатель на вторую cтрока.
    @return True - если строки одинаковые, false - разные.
*/
#define string_equali(lstr, rstr) platform_string_equali(lstr, rstr)

/*
    @brief Выполняет форматирование строки в соответствии с заданным форматом
           строки и переменными.
    @param dest Указатель на память куда записать отформатированную строку.
    @param format Формат строки, который указывает как должна выглядеть строка.
    @param ... Параметры строки формата.
    @return Количество записаных символов отформатированной строки.
*/
#define string_format(dest, format, ...) platform_string_format(dest, format, ##__VA_ARGS__)

/*
    @brief Выполняет форматирование строки в соответствии с заданным форматом
           строки и указателем на переменные.
    @param dest Указатель на память куда записать отформатированную строку.
    @param length Количество символов которое будет записано, включая завершающий (\0).
    @param format Формат строки, который указывает как должна выглядеть строка.
    @param va_list Указатель на параметры строки формата.
    @return Количество записаных символов отформатированной строки.
*/
#define string_formatv(dest, length, format, va_list) platform_string_formatv(dest, length, format, va_list)

/*
    @brief Создает дубликат строки.
    NOTE: После использования удалить с помощью функуии 'string_free'.
    @param str Указатель на строку.
    @return Указатель на дубликат строки.
*/
KAPI char* string_duplicate(const char* str);

/*
    @brief Удаляет указанную строку.
    NOTE: Удалить можно только строку созданную данной библиотекой.
    @param str Указатель на строку.
*/
KAPI void string_free(const char* str);

/*
    @brief Очищает строку установкой первого символа в '\0'.
    @param str Указатель на строку.
    @return Возвращает указатель на строку.
*/
KAPI char* string_empty(char* str);

/*
    @brief Копирует строку полностью.
    NOTE: Память куда копируется строка должны быть больше на 1 символ.
    @param dest Указатель на память куда скопировать.
    @param src Указатель на строку откуда копировать.
    @return Указатель на скопированую строку.
*/
#define string_copy(dest, src) platform_string_copy(dest, src)

/*
    @brief Копирует заданное количество байт строки.
    @param dest Указатель на память куда скопировать.
    @param src Указатель на строку откуда копировать.
    @param length Максимальное количество символов для копирования.
    @return Указатель на скопированую строку.
*/
#define string_ncopy(dest, src, length) platform_string_ncopy(dest, src, length)

/*
    @brief Удаляет из текущей строки все начальные и конечные символы пробелов.
    NOTE: Модифицирует строку.
    @param str Указатель на строку для удаления символов.
    @return Указатель на смещение в строке.
*/
KAPI char* string_trim(char* str);

/*
    @brief Получает подстроку из строки заданного размера.
    @param dest Указатель на память куда скопировать.
    @param src Указатель на строку откуда копировать.
*/
KAPI void string_mid(char* dest, const char* src, u64 start, i64 length);

/*
    @brief Указывает позицию первого совпадения искомого символа.
    @param str Указатель на строку для поиска.
    @param c Искомый символ.
    @return Позиция символа в строке, -1 если символ не найден.
*/
KAPI i64 string_index_of(char* str, char c);

/*
    @brief Попытка преобразовать строку (т.е. "1.0 2.0 3.0 4.0") в вектор.
    @param str Указатель на строку откуда читать. Резделитель - пробел.
    @param out_vector Указатель на вектор, куда записывать.
    @return True если преобразование прошло успешно, false если не удалось.
*/
KAPI bool string_to_vec4(char* str, vec4* out_vector);

/*
    @brief Попытка преобразовать строку (т.е. "1.0 2.0 3.0") в вектор.
    @param str Указатель на строку откуда читать. Резделитель - пробел.
    @param out_vector Указатель на вектор, куда записывать.
    @return True если преобразование прошло успешно, false если не удалось.
*/
KAPI bool string_to_vec3(char* str, vec3* out_vector);

/*
    @brief Попытка преобразовать строку (т.е. "1.0 2.0") в вектор.
    @param str Указатель на строку откуда читать. Резделитель - пробел.
    @param out_vector Указатель на вектор, куда записывать.
    @return True если преобразование прошло успешно, false если не удалось.
*/
KAPI bool string_to_vec2(char* str, vec2* out_vector);

/*
    @brief Попытка преобразовать строку в 32-bit число с плавающей точкой.
    @param str Указатель на строку откуда читать. Без модификаторов!
    @param value Указатель на 32-bit число с плавающей точкой, куда записывать.
    @return True если преобразование прошло успешно, false если не удалось.
*/
KAPI bool string_to_f32(char* str, f32* value);

/*
    @brief Попытка преобразовать строку в 64-bit число с плавающей точкой.
    @param str Указатель на строку откуда читать. Без модификаторов!
    @param value Указатель на 64-bit число с плавающей точкой, куда записывать.
    @return True если преобразование прошло успешно, false если не удалось.
*/
KAPI bool string_to_f64(char* str, f64* value);

/*
    @brief Попытка преобразовать строку в 8-bit целочисленное число со знаком.
    @param str Указатель на строку откуда читать. Без модификаторов!
    @param value Указатель на 8-bit целочисленное число со знаком, куда записывать.
    @return True если преобразование прошло успешно, false если не удалось.
*/
KAPI bool string_to_i8(char* str, i8* value);

/*
    @brief Попытка преобразовать строку в 16-bit целочисленное число со знаком.
    @param str Указатель на строку откуда читать. Без модификаторов!
    @param value Указатель на 16-bit целочисленное число со знаком, куда записывать.
    @return True если преобразование прошло успешно, false если не удалось.
*/
KAPI bool string_to_i16(char* str, i16* value);

/*
    @brief Попытка преобразовать строку в 32-bit целочисленное число со знаком.
    @param str Указатель на строку откуда читать. Без модификаторов!
    @param value Указатель на 32-bit целочисленное число со знаком, куда записывать.
    @return True если преобразование прошло успешно, false если не удалось.
*/
KAPI bool string_to_i32(char* str, i32* value);

/*
    @brief Попытка преобразовать строку в 64-bit целочисленное число со знаком.
    @param str Указатель на строку откуда читать. Без модификаторов!
    @param value Указатель на 64-bit целочисленное число со знаком, куда записывать.
    @return True если преобразование прошло успешно, false если не удалось.
*/
KAPI bool string_to_i64(char* str, i64* value);

/*
    @brief Попытка преобразовать строку в 8-bit целочисленное число без знака.
    @param str Указатель на строку откуда читать. Без модификаторов!
    @param value Указатель на 8-bit целочисленное число без знака, куда записывать.
    @return True если преобразование прошло успешно, false если не удалось.
*/
KAPI bool string_to_u8(char* str, u8* value);

/*
    @brief Попытка преобразовать строку в 16-bit целочисленное число без знака.
    @param str Указатель на строку откуда читать. Без модификаторов!
    @param value Указатель на 16-bit целочисленное число без знака, куда записывать.
    @return True если преобразование прошло успешно, false если не удалось.
*/
KAPI bool string_to_u16(char* str, u16* value);

/*
    @brief Попытка преобразовать строку в 32-bit целочисленное число без знака.
    @param str Указатель на строку откуда читать. Без модификаторов!
    @param value Указатель на 32-bit целочисленное число без знака, куда записывать.
    @return True если преобразование прошло успешно, false если не удалось.
*/
KAPI bool string_to_u32(char* str, u32* value);

/*
    @brief Попытка преобразовать строку в 64-bit целочисленное число без знака.
    @param str Указатель на строку откуда читать. Без модификаторов!
    @param value Указатель на 64-bit целочисленное число без знака, куда записывать.
    @return True если преобразование прошло успешно, false если не удалось.
*/
KAPI bool string_to_u64(char* str, u64* value);

/*
    @brief Попытка преобразовать строку в логическое значение.
    NOTE: "True" или "true" или "1" - true, в остальных случаях false.
    @param str Указатель на строку откуда читать. Без модификаторов!
    @param value Указатель на логическое значение, куда записывать.
    @return True если преобразование прошло успешно, false если не удалось.
*/
KAPI bool string_to_bool(char* str, bool* value);

/*
    @brief Разбивает строку по предоставленому разделителю и сохраняет в динамический массив (darray).
    NOTE: Перед уничтожение массива необходимо освободить память вызовом функции 'string_cleanup_split_array'.
    @param str Указатель на строку над которой нужно провести разделение.
    @param delim Символ разделителя.
    @param trime_entries Обрезать каждую получившуюся строку перед добавлением в массив.
    @param include_empty Включать пустые строки в массив.
    @param str_darray Указатель на массив строк для получения результата (используется darray).
    @return Число получившихся строк в результате разделения, 0 если не удалось выполнить разделение.
*/
KAPI u32 string_split(const char* str, char delim, bool trime_entries, bool include_empty, char*** str_darray);

/*
    @brief Освобождает строки динамического массива в результате выполнения функции 'string_split'.
    @param str_darray Указатель на массив строк для освобождения выделенной памяти (используется darray).
*/
KAPI void string_cleanup_split_array(char** str_darray);
